<!DOCTYPE html>
<html>
<head>
  <meta foo="bar">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="astro und hoodie">
  <meta name="dcterms.date" content="2016-02-10">
  <title>Rust</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
  <style type="text/css"></style>
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="./highlight.pack.js"></script>
  <link rel="stylesheet" href="slide-style.css"/>
  <link rel="stylesheet" href="styles/tomorrow.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Rust</h1>
  <h2 class="author">astro und hoodie</h2>
  <h3 class="date">February 10, 2016</h3>
</section>

<section><section id="was-ist-rust" class="titleslide slide level1"><h1>Was ist Rust?</h1></section><section id="eine-programmiersprache" class="slide level2">
<h1>eine Programmiersprache!</h1>
<ul>
<li>entwickelt von Mozilla, seit 2007</li>
<li>stabil seit Mai 2015</li>
</ul>
</section><section id="beispiele" class="slide level2">
<h1>Beispiele:</h1>
<ul>
<li>Servo <em>(super cool fast browser engine)</em></li>
<li>machine learning tools (<a href="https://github.com/autumnai/leaf">leaf</a>, <a href="https://github.com/maciejkula/rustlearn">rustlearn</a>)</li>
<li>rustc selbst</li>
<li>safe parsers (<a href="https://github.com/Geal/nom">nom</a>)</li>
<li><a href="https://robigalia.org/">seL4 stack</a></li>
<li>Maidsafe</li>
</ul>
</section></section>
<section><section id="vergleiche" class="titleslide slide level1"><h1>Vergleiche</h1></section><section id="rust-ist-wie-..." class="slide level2">
<h1>Rust ist wie ...</h1>
<ul>
<li>... c/c++</li>
<li>... haskell</li>
<li>... ruby</li>
<li>... python</li>
</ul>
<div class="fragment">
<p>und doch ganz anders</p>
</div>
</section><section id="wie-cc" class="slide level2">
<h1>wie c/c++</h1>
<ul>
<li>statisch kompiliert <em>LLVM</em></li>
<li>schnell</li>
<li>kein garbage-collector</li>
<li>Generics</li>
<li>zero cost abstractions</li>
<li><strong>low level</strong></li>
</ul>
</section><section id="wie-haskell" class="slide level2">
<h1>wie haskell</h1>
<ul>
<li>streng getypt</li>
<li>Hindley-Milner type system</li>
<li>Immutable Variablen</li>
<li>Pattern Matching</li>
<li>lambda-Ausdrücke/Closures</li>
</ul>
</section><section id="wie-ruby-oder-python" class="slide level2">
<h1>wie ruby oder python</h1>
<ul>
<li>expressive Syntax</li>
<li>gut zu lesen</li>
<li>Build system und Packetmanager (cargo &amp; crates.io)</li>
</ul>
</section><section id="wie-rust-eben" class="slide level2">
<h1>wie rust eben!</h1>
<ul>
<li><strong>borrow checker</strong></li>
<li>lifetimes Syntax</li>
<li>sehr explizit</li>
</ul>
</section><section id="einflüße" class="slide level2">
<h1>Einflüße</h1>
<ul>
<li><strong>SML, OCaml:</strong> algebraic data types, pattern matching, type inference, semicolon statement separation</li>
<li><strong>C++:</strong> references, RAII, smart pointers, move semantics, monomorphization, memory model</li>
<li><strong>ML Kit, Cyclone:</strong> region based memory management</li>
<li><strong>Haskell (GHC):</strong> typeclasses, type families</li>
<li><strong>Newsqueak, Alef, Limbo:</strong> channels, concurrency</li>
</ul>
</section><section id="einflüße-1" class="slide level2">
<h1>Einflüße</h1>
<ul>
<li><strong>Erlang:</strong> message passing, thread failure</li>
<li><strong>Swift:</strong> optional bindings</li>
<li><strong>Scheme:</strong> hygienic macros</li>
<li><strong>C#:</strong> attributes</li>
<li><strong>Unicode Annex #31:</strong> identifier and pattern syntax</li>
</ul>
<p>siehe: <a href="http://doc.rust-lang.org/reference.html#appendix-influences">influences</a></p>
</section></section>
<section><section id="features" class="titleslide slide level1"><h1>Features</h1></section><section id="sicherheit" class="slide level2">
<h1>Sicherheit</h1>
<ul>
<li>Speichersicherheit</li>
<li><p>Cuncurrency ohne Speicherverletzungen</p></li>
<li><em>move semantics</em></li>
<li>Type inference</li>
<li>Typsicherheit zur Compilezeit</li>
<li><p>keine implizites casting</p></li>
</ul>
</section><section id="leistung" class="slide level2">
<h1>Leistung</h1>
<ul>
<li><a href="http://blog.rust-lang.org/2015/05/11/traits.html">zero-cost abstractions</a></li>
<li>minimale Runtime</li>
<li>effiziente C Bindings</li>
</ul>
</section><section id="sprache" class="slide level2">
<h1>Sprache</h1>
<ul>
<li>trait-based generics</li>
<li>pattern matching</li>
<li>hygienische macros</li>
<li>expressions und statements</li>
<li>closures</li>
<li>Beispiele folgen</li>
</ul>
</section><section id="ökosystem" class="slide level2">
<h1>Ökosystem</h1>
<ul>
<li>Dokumentation ist TopPriority</li>
<li>in-line Tests und Benchmarks
<ul>
<li><code>#[test]</code></li>
<li><code>#[bench]</code></li>
</ul></li>
<li>cargo kompiliert, dokumentiert, testet, benchmarkt und publisht</li>
</ul>
</section><section id="cargo" class="slide level2">
<h1>Cargo</h1>
<ul>
<li>cargo as package manager and build system</li>
<li>crates.io as repo, extern git repositories, explizite</li>
<li>Gleich benutzen</li>
<li>Macht den Umgang mit external crates möglich</li>
</ul>
</section><section id="wohin-mit-dem-code" class="slide level2">
<h1>Wohin mit dem Code?</h1>
<ul>
<li>Libraries: <code>src/**/lib.rs</code></li>
<li>Binaries: <code>src/main.rs src/bin/*.rs</code></li>
</ul>
</section></section>
<section><section id="beispiele-1" class="titleslide slide level1"><h1>Beispiele</h1></section><section id="hello-world" class="slide level2">
<h1>Hello world</h1>
<pre class="rust"><code>fn main(){
  println!(&quot;hello world&quot;);
}</code></pre>
<div class="fragment">
<p>Vorsicht, Macro!</p>
</div>
</section><section id="formatted-print" class="slide level2">
<h1>Formatted Print</h1>
<pre class="rust"><code>fn main() {

    println!(&quot;{} entspricht {:b} &quot;, 42, 42);

    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);

    // As can named arguments.
    println!(&quot;Themenabend   \&quot;{subject}\&quot;&quot;, subject=&quot;Rust&quot;,);

    // Alignment
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

}</code></pre>
</section><section id="debug-print" class="slide level2">
<h1>Debug Print</h1>
<pre class="rust"><code>fn main(){

    #[derive(Debug)]
    struct Themenabend{
      number: i32,
      title: &amp;&#39;static str,
    };

    println!(&quot;Interne Struktur von {:?}&quot;,
    Themenabend{
      number:3,
      title:&quot;Rust Themenabend&quot;
    });
}</code></pre>
</section></section>
<section><section id="datentypen" class="titleslide slide level1"><h1>Datentypen</h1></section><section id="vectors" class="slide level2">
<h1>Vectors</h1>
<pre class="rust"><code>fn main() {
let _list = vec![1,2,3,4];

// entspricht

let _list2 = {
  let mut list = Vec::new();
  list.push(1);
  list.push(2);
  //...
  list
};

let _range: Vec&lt;i32&gt; = (0..10).collect();
}</code></pre>
</section><section id="options" class="slide level2">
<h1>Options</h1>
<pre class="rust-norun"><code>pub enum Option&lt;T&gt; {
    Some(T),
    None
}</code></pre>
<div class="fragment">
<pre class="rust"><code>fn divide(a:i32, b:i32) -&gt; Option&lt;i32&gt;{
  if b == 0 {
    None
  } else { Some(a/b) }
}

fn main(){
  println!(&quot;12/3 = {:?}&quot;, divide(12,3));
  println!(&quot;12/0 = {:?}&quot;, divide(12,0));
}</code></pre>
</div>
</section><section id="primitive" class="slide level2">
<h1>Primitive</h1>
<pre class="rust-norun"><code>fn main(){
  let one = 1u32;
  let fourtytwo= 0b101010;
  let goku = 9_001;
  let ladies = (&quot;x&quot;,&quot;y&quot;);
}</code></pre>
</section><section id="pointers" class="slide level2">
<h1>Pointers</h1>
<pre class="rust-norun"><code>fn main(){
  let sushi = Box::new((&quot;rice&quot;, &quot;fish&quot;));
}</code></pre>
</section></section>
<section><section id="sicher-schnell-wie" class="titleslide slide level1"><h1>Sicher, schnell, wie?</h1></section><section id="memory-model" class="slide level2">
<h1>Memory Model</h1>
<ul>
<li>kein GarbageCollector</li>
<li>keine manuelle Speicherverwaltung</li>
<li><strong>borrow checker</strong> forciert Ownership and Move Semantics</li>
<li>Destruktor: <code>trait Drop</code></li>
</ul>
</section><section id="move-semantics-1" class="slide level2">
<h1>Move Semantics 1</h1>
<pre class="rust"><code>fn main(){
  let list = vec![1,2,3];
  let x = list;
  let y = list; // Compiletime Error: use after move
}</code></pre>
</section><section id="move-semantics-2" class="slide level2">
<h1>Move Semantics 2</h1>
<pre class="rust"><code>fn do_some(_foo:Vec&lt;i32&gt;){
    // konsumiert `foo`
}

fn main(){
  let list = vec![1,2,3];
  println!(&quot;{}&quot;, list[0]);
  do_some(list);
  println!(&quot;{}&quot;, list[0]); // fails
}</code></pre>
</section><section id="sharing-is-caring-1" class="slide level2">
<h1>Sharing is Caring 1</h1>
<pre class="rust"><code>fn main(){
  let list = vec![1,2,3];
  let x = &amp;list;
  let y = list; // Compiletime Error: use while borrowed
}</code></pre>
<div class="fragment">
<p>Warum also? Borrowing gilt nur innerhalb von Scopes!</p>
</div>
</section><section id="sharing-is-caring-2" class="slide level2">
<h1>Sharing is Caring 2</h1>
<pre class="rust"><code>fn main(){
  let list = vec![1,2,3];
  {
    let _x = &amp;list;
  }
  let _y = list;
}</code></pre>
</section><section id="borrowing" class="slide level2">
<h1>Borrowing</h1>
<pre class="rust"><code>fn do_some(_foo:&amp;Vec&lt;i32&gt;){
}

fn main(){
  let list = vec![1,2,3];
  println!(&quot;{}&quot;, list[0]);

  do_some(&amp;list);          // explitzite Referenz, unlike C++
  println!(&quot;{}&quot;, list[0]); // fails no more
}</code></pre>
</section><section id="references-at-a-glance" class="slide level2">
<h1>References at a glance</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Funktion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>T</code></td>
<td style="text-align: left;">Basistyp</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mut T</code></td>
<td style="text-align: left;">veränderlicher Typ</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&amp;T</code></td>
<td style="text-align: left;">read-only Referenz <em>niemand kann schreiben</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&amp;mut T</code></td>
<td style="text-align: left;">schreibbare Referenze <em>nur einer kann schreiben</em></td>
</tr>
</tbody>
</table>
<pre class="rust-norun"><code>let v:Vec&lt;i32&gt; = vec![1,2,3,4];
let v_ref:&amp;Vec&lt;i32&gt; = &amp;v;</code></pre>
<pre class="rust-norun"><code>let mut v:Vec&lt;i32&gt; = vec![1,2,3,4];
let v_ref:&amp;mut Vec&lt;i32&gt; = &amp;mut v;</code></pre>
</section><section id="usecases" class="slide level2">
<h1>Usecases</h1>
<div class="fragment">
<pre class="rust-norun"><code>fn read(v: &amp;Vec&lt;String&gt;) -&gt; String {
    let first: &amp;String = &amp;v[0]; // borrow ref to first elem
    println!(&quot;v[0]: {}&quot;, first);
    first.clone()
}</code></pre>
</div>
<div class="fragment">
<pre class="rust-norun"><code>fn modify(v: &amp;mut Vec&lt;String&gt;, name: &amp;str) {
    let freshly_created = format!(&quot;Hello {}&quot;, name);
    v.push(freshly_created);
}</code></pre>
</div>
<div class="fragment">
<pre class="rust-norun"><code>fn consume(v: Vec&lt;String&gt;) -&gt; String {
    for s in v { return s; }
    panic!(&quot;v was empty?!?&quot;);
}</code></pre>
</div>
<div class="fragment">
<pre class="rust-norun"><code>fn read(v: &amp;Vec&lt;String&gt;) -&gt; String { ... }
fn modify(v: &amp;mut Vec&lt;String&gt;, name: &amp;str) { ... }
fn consume(v: Vec&lt;String&gt;) -&gt; String { ... }</code></pre>
</div>
</section></section>
<section><section id="control-flow" class="titleslide slide level1"><h1>Control Flow</h1></section><section id="what-if" class="slide level2">
<h1>what if?</h1>
<pre class="rust-norun"><code>let x = 5;
if x == 5 {
    println!(&quot;x is five!&quot;);
} else if x == 6 {
    println!(&quot;x is six!&quot;);
} else {
    println!(&quot;x is not five or six :(&quot;);
}</code></pre>
<div class="fragment">
<pre class="rust-norun"><code>let y = if x == 5 {
    10
} else {
    15
}; // y: i32</code></pre>
</div>
</section><section id="switch-cases" class="slide level2">
<h1>Switch cases?</h1>
<pre class="cpp"><code>int main(){
    int auswahl;

    cout &lt;&lt; &quot;Wählen Sie Ihre Lieblingsleckerei:\n&quot;
            &quot;1 - Käsesahnetorte\n&quot;
            &quot;2 - Streuselkuchen\n&quot;
            &quot;3 - Windbeutel\n&quot;;

    cin &gt;&gt; auswahl;

    switch(auswahl){
        case 1:  cout &lt;&lt; &quot;Käsesahnetorte!&quot;;
        case 2:  cout &lt;&lt; &quot;Streuselkuchen&quot;;
        case 3:  cout &lt;&lt; &quot;Windbeutel&quot;;
        default: cout &lt;&lt; &quot;Nein Danke&quot;;
    }
}</code></pre>
<div class="fragment">
<pre><code>Streuselkuchen Windbeutel Nein Danke</code></pre>
</div>
</section><section id="matching" class="slide level2">
<h1>Matching</h1>
<pre class="rust-norun"><code>let auswahl = 2;
match auswahl {
        1 =&gt; println!(&quot;Käsesahnetorte!&quot;),
        2 =&gt; println!(&quot;Streuselkuchen&quot;),
        3 =&gt; println!(&quot;Windbeutel&quot;),
        _ =&gt; println!(&quot;Nein Danke&quot;)
}</code></pre>
<pre class="rust-norun"><code>match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}</code></pre>
<pre class="rust-norun"><code>let origin = Point { x: 0, y: 0 };
match origin {
    Point { y, .. } =&gt; println!(&quot;y is {}&quot;, y),
}</code></pre>
<pre class="rust-norun"><code>match &#39;f&#39; {
    &#39;a&#39; ... &#39;j&#39; =&gt; println!(&quot;early letter&quot;),
    &#39;k&#39; ... &#39;z&#39; =&gt; println!(&quot;late letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}</code></pre>
</section><section id="loops" class="slide level2">
<h1>loops</h1>
<pre class="rust-norun"><code>loop {
    println!(&quot;Loop forever!&quot;);
}</code></pre>
<div class="fragment">
<pre class="rust-norun"><code>while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 { done = true; }
}
</code></pre>
</div>
</section></section>
<section><section id="oop" class="titleslide slide level1"><h1>OOP ?</h1></section><section id="struct-und-enum" class="slide level2">
<h1>struct und enum</h1>
<pre class="rust-norun"><code>struct Point { x: i32, y: i32 }</code></pre>
<div class="fragment">
<pre class="rust-norun"><code>enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}</code></pre>
</div>
</section><section id="impl" class="slide level2">
<h1>Impl</h1>
<pre class="rust-norun"><code>struct Point { x: i32, y: i32 }

impl Point {
    fn distance_from_origin(&amp;self) -&gt; i32 {
        let Point { x, y } = *self;
        let sum = (x*x + y*y) as f64;
        sum.sqrt() as i32
    }
}</code></pre>
<div class="fragment">
<ul>
<li><code>self</code> : Kurz für <code>self:Self</code>, konsumiert</li>
<li><code>&amp;self</code> : Read-only</li>
<li><code>&amp;mut self</code> : Read-Write</li>
</ul>
</div>
</section><section id="drop" class="slide level2">
<h1>Drop</h1>
<pre class="rust-norun"><code>struct Point { x: i32, y: i32 }

impl Point {
    fn Drop(self) {
    }
}</code></pre>
</section><section id="traits" class="slide level2">
<h1>Traits</h1>
</section><section class="slide level2">

</section></section>
<section><section id="here-be-dragons" class="titleslide slide level1"><h1>here be dragons</h1></section><section id="der-rest-ist-unsortiert" class="slide level2">
<h1>der rest ist unsortiert</h1>
<ul>
<li>Traits vs Object Orientation -&gt; composition vs inheritance</li>
<li>Trait based Generics vs Templates -&gt; no ducktyping in &quot;template&quot; expansions</li>
<li>no nullpointers =&gt; functions return <code>Option&lt;T&gt;</code> or <code>Result&lt;T&gt;</code></li>
<li>functional style Error Handling, no exceptions :)</li>
</ul>
</section><section id="concurrency" class="slide level2">
<h1>Concurrency</h1>
<ul>
<li>mpsc channels</li>
<li>ownership is enforced -&gt; no Dataraces</li>
<li>shared access through <code>Arc</code></li>
</ul>
<pre class="rust"><code>use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(
        Mutex::new(
            vec![1, 2, 3]
            )
        );

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}</code></pre>
</section><section id="macros" class="slide level2">
<h1>Macros</h1>
<ul>
<li>very unlike C/C++ Macros</li>
<li>work on AST after parser</li>
<li><strong>example</strong></li>
</ul>
</section></section>
<section><section id="handson-life-coding-examples" class="titleslide slide level1"><h1>HandsOn: Life Coding Examples</h1></section><section id="basics" class="slide level2">
<h1>Basics</h1>
<ol>
<li>(im)mutability</li>
<li>primitives and tuple, enum, struct</li>
<li>control flow (if, loop, while)</li>
<li>expressions vs statements</li>
<li>println!()</li>
</ol>
</section><section id="get-rusty" class="slide level2">
<h1>Get Rusty</h1>
<ol>
<li>references (e.g. String vs &amp;str)</li>
<li>Option and Result</li>
<li>pattern matching (match, if let)</li>
<li>error handling, simple</li>
</ol>
</section><section id="stdlib" class="slide level2">
<h1>Stdlib</h1>
<ol>
<li>collections</li>
<li>iterators</li>
</ol>
</section><section id="advanced" class="slide level2">
<h1>Advanced</h1>
<ol>
<li>closures</li>
<li>traits, trait bounds</li>
<li>documentation comments, in-line tests <code>#[test]</code> and benchmarks <code>#[bench]</code></li>
<li>error handling, closer look</li>
</ol>
</section><section id="for-completeness-sake" class="slide level2">
<h1>For Completeness Sake</h1>
<ol>
<li>modules</li>
<li>macros ( please don't )</li>
</ol>
</section></section>
<section><section id="extension-slides" class="titleslide slide level1"><h1>Extension Slides</h1></section><section id="section" class="slide level2">
<h1></h1>
</section></section>
<section><section id="eco-system" class="titleslide slide level1"><h1>eco system</h1></section><section id="community-and-documentation" class="slide level2">
<h1>Community and Documentation</h1>
<ul>
<li>users.rust-lang.org</li>
<li>http://rustbyexample.com/</li>
<li>http://doc.rust-lang.org/stable/book/</li>
<li>http://www.reddit.com/r/rust</li>
<li>http://rustyrad.io/</li>
<li>http://this-week-in-rust.org/</li>
<li>http://cglab.ca/~abeinges/blah/turpl/_book/</li>
</ul>
</section><section id="cargo.toml" class="slide level2">
<h1>Cargo.toml</h1>
<p>ownership/borrowing: use-case cache</p>
<p>struct Cache { cached: Option<i32>; }</p>
<p>impl Cache { pub fn get(&amp;mut self) -&gt; &amp;i32 { match self.cached { Some(ref cached) =&gt; cached; None =&gt; { self.cached = 32; &amp;self.cached } } } }</p>
<p>Typing-Beispiele: Fresh in Hyper, pulse-simple</p>
</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>
  <script src="jquery-1.12.0.min.js"></script>
  <script src="add_playpen.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
