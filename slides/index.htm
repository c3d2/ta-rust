<!DOCTYPE html>
<html>
<head>
  <meta foo="bar">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="astro und hoodie">
  <meta name="dcterms.date" content="2016-01-11">
  <title>Rust Themenabend</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
  <style type="text/css"></style>
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="./highlight.pack.js"></script>
  <link rel="stylesheet" href="slide-style.css"/>
  <link rel="stylesheet" href="styles/tomorrow.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Rust Themenabend</h1>
  <h2 class="author">astro und hoodie</h2>
  <h3 class="date">January 11, 2016</h3>
</section>

<section><section id="was-ist-rust" class="titleslide slide level1"><h1>Was ist Rust?</h1></section><section id="existiert-seit" class="slide level2">
<h1>existiert seit</h1>
<ul>
<li>developed <span class="citation" data-cites="mozilla">@mozilla</span> since ~2007</li>
<li>stable since May 2015</li>
</ul>
</section><section id="rust-powers" class="slide level2">
<h1>Rust powers:</h1>
<ul>
<li>Servo <em>(super cool fast browser engine)</em></li>
<li>machine learning tools (<a href="https://github.com/autumnai/leaf">leaf</a>, <a href="https://github.com/maciejkula/rustlearn">rustlearn</a>)</li>
<li>safe parsers (<a href="https://github.com/Geal/nom">nom</a>)</li>
<li><a href="https://robigalia.org/">seL4 stack</a></li>
<li>everything else</li>
</ul>
</section></section>
<section><section id="vergleiche" class="titleslide slide level1"><h1>Vergleiche</h1></section><section id="rust-ist-wie-..." class="slide level2">
<h1>Rust ist wie ...</h1>
<ul>
<li>... c++</li>
<li>... haskell</li>
<li>... ruby</li>
<li>... python</li>
</ul>
</section><section id="wie-c" class="slide level2">
<h1>wie c++</h1>
<ul>
<li>statisch kompiliert <em>LLVM</em></li>
<li>scheiße schnell</li>
<li>zero cost abstractions</li>
<li>kein garbage-collector</li>
<li><strong>low level</strong></li>
</ul>
</section><section id="wie-haskell" class="slide level2">
<h1>wie haskell</h1>
<ul>
<li>streng getypt</li>
<li>Hindley-Milner type system</li>
<li>immutable by default</li>
<li>ziemlich funktional</li>
</ul>
</section><section id="wie-ruby-oder-python" class="slide level2">
<h1>wie ruby oder python</h1>
<ul>
<li>expressive Syntax</li>
<li>gut zu lesen</li>
<li>Buildsystem und Paketmanager (cargo &amp; crates.io)</li>
</ul>
</section><section id="wie-rust" class="slide level2">
<h1>wie rust!</h1>
<ul>
<li><strong>borrow checker</strong></li>
</ul>
</section><section id="einflüße" class="slide level2">
<h1>Einflüße</h1>
<ul>
<li><strong>SML, OCaml:</strong> algebraic data types, pattern matching, type inference, semicolon statement separation</li>
<li><strong>C++:</strong> references, RAII, smart pointers, move semantics, monomorphization, memory model</li>
<li><strong>ML Kit, Cyclone:</strong> region based memory management</li>
<li><strong>Haskell (GHC):</strong> typeclasses, type families</li>
<li><strong>Newsqueak, Alef, Limbo:</strong> channels, concurrency</li>
</ul>
</section><section id="einflüße-1" class="slide level2">
<h1>Einflüße</h1>
<ul>
<li><strong>Erlang:</strong> message passing, thread failure</li>
<li><strong>Swift:</strong> optional bindings</li>
<li><strong>Scheme:</strong> hygienic macros</li>
<li><strong>C#:</strong> attributes</li>
<li><strong>Unicode Annex #31:</strong> identifier and pattern syntax</li>
</ul>
<p>siehe: <a href="http://doc.rust-lang.org/reference.html#appendix-influences">influence</a></p>
</section></section>
<section><section id="features" class="titleslide slide level1"><h1>Features</h1></section><section id="sicherheit" class="slide level2">
<h1>Sicherheit</h1>
<ul>
<li>guaranteed memory safety</li>
<li><p>threads without data races</p></li>
<li>move semantics</li>
<li>Type inference</li>
<li><p>Typsicherheit zur compile time -&gt; no implicit coercions/casting</p></li>
</ul>
</section><section id="leistung" class="slide level2">
<h1>Leistung</h1>
<ul>
<li>zero-cost abstractions</li>
<li>minimal runtime</li>
<li>efficient C bindings</li>
</ul>
</section><section id="sprache" class="slide level2">
<h1>Sprache</h1>
<ul>
<li>trait-based generics</li>
<li>pattern matching</li>
<li>hygienische macros</li>
<li>expressions und statements</li>
<li>closures</li>
<li>Beispiele folgen</li>
</ul>
</section><section id="ökosystem" class="slide level2">
<h1>Ökosystem</h1>
<ul>
<li>Dokumentation ist TopPriority</li>
<li>in-line Tests und Benchmarks
<ul>
<li><code>#[test]</code></li>
<li><code>#[bench]</code></li>
</ul></li>
<li>cargo kompiliert, dokumentiert, testet, benchmarkt und publisht</li>
</ul>
</section></section>
<section><section id="beispiele" class="titleslide slide level1"><h1>Beispiele</h1></section><section id="hello-world" class="slide level2">
<h1>Hello world</h1>
<pre class="rust"><code>fn main(){
  println!(&quot;hello world&quot;);
}

* macro</code></pre>
</section><section id="formatted-print" class="slide level2">
<h1>Formatted Print</h1>
<pre class="rust"><code>fn main() {

    println!(&quot;{0} entspricht {0:b} &quot;, 42);

    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);

    // As can named arguments.
    println!(&quot;Themenabend   \&quot;{subject}\&quot;&quot;, subject=&quot;Rust&quot;,);

    // Alignment
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

}</code></pre>
</section><section id="debug-print" class="slide level2">
<h1>Debug Print</h1>
<pre class="rust"><code>fn main(){

    #[derive(Debug)]
    struct Themenabend{
      number: i32,
      title: &amp;&#39;static str,
    };

    println!(&quot;Interne Struktur von {:?}&quot;,
    Themenabend{
      number:3,
      title:&quot;Rust Themenabend&quot;
    });
}</code></pre>
</section></section>
<section><section id="datentypen" class="titleslide slide level1"><h1>Datentypen</h1></section><section id="vectors" class="slide level2">
<h1>Vectors</h1>
<pre class="rust"><code>fn main() {
let _list = vec![1,2,3,4];

// entspricht

let _list2 = {
  let mut list = Vec::new();
  list.push(1);
  list.push(2);
  //...
  list
};

let _range: Vec&lt;i32&gt; = (0..10).collect();
}</code></pre>
</section><section id="options" class="slide level2">
<h1>Options</h1>
<pre class="rust"><code>fn divide(a:i32, b:i32) -&gt; Option&lt;i32&gt;{
  if b == 0 {
    None
  } else { Some(a/b) }
}

fn main(){
  println!(&quot;12/3 = {:?}&quot;, divide(12,3));
  println!(&quot;12/0 = {:?}&quot;, divide(12,0));
}</code></pre>
</section><section id="primitive" class="slide level2">
<h1>Primitive</h1>
<pre class="rust"><code>fn main(){
  let one = 1u32;
  let fourtytwo= 0b101010;
  let goku = 9_001;
  let ladies = (&quot;x&quot;,&quot;y&quot;);
}</code></pre>
</section><section id="pointers" class="slide level2">
<h1>Pointers</h1>
<pre class="rust"><code>fn main(){
  let sushi = Box::new((&quot;rice&quot;, &quot;fish&quot;));
}</code></pre>
</section></section>
<section><section id="sicher-schnell-wie" class="titleslide slide level1"><h1>Sicher, schnell, wie?</h1></section><section id="memory-model" class="slide level2">
<h1>Memory Model</h1>
<ul>
<li>kein GarbageCollector</li>
<li>keine manuelle Speicherverwaltung</li>
<li><strong>borrow checker</strong> forciert Ownership and Move Semantics</li>
</ul>
</section><section id="move-semantics-12" class="slide level2">
<h1>Move Semantics 1/2</h1>
<pre class="rust"><code>fn main(){
  let list = vec![1,2,3];
  let x = list;
  let y = list;
}</code></pre>
</section><section id="move-semantics-22" class="slide level2">
<h1>Move Semantics 2/2</h1>
<pre class="rust"><code>fn do_some(_foo:Vec&lt;i32&gt;){
    // konsumiert `foo`
}

fn main(){
  let list = vec![1,2,3];
  println!(&quot;{}&quot;, list[0]);
  do_some(list);
  println!(&quot;{}&quot;, list[0]); // fails
}</code></pre>
</section><section id="sharing-is-caring" class="slide level2">
<h1>Sharing is Caring</h1>
<pre class="rust"><code>fn main(){
  let list = vec![1,2,3];
  let x = &amp;list;
  let y = list;
}</code></pre>
</section><section id="borrowing" class="slide level2">
<h1>Borrowing</h1>
<pre class="rust"><code>fn do_some(_foo:&amp;Vec&lt;i32&gt;){
}

fn main(){
  let list = vec![1,2,3];
  println!(&quot;{}&quot;, list[0]);

  do_some(&amp;list);          // explitzit
  println!(&quot;{}&quot;, list[0]); // fails no more
}</code></pre>
</section><section id="references-at-a-glance" class="slide level2">
<h1>References at a glance</h1>
<ul>
<li><code>T</code> Basistyp</li>
<li><code>mut T</code> veränderlicher Typ</li>
<li><code>&amp;T</code> read-only Referenz</li>
<li>niemand kann schreiben</li>
<li><code>&amp;mut T</code> schreibbare Referenze</li>
<li>nur einer kann schreiben</li>
</ul>
</section><section id="beispiele-1" class="slide level2">
<h1>Beispiele</h1>
<pre class="rust-norun"><code>fn read(v: &amp;Vec&lt;String&gt;) -&gt; String {
    let first: &amp;String = &amp;v[0]; // borrow ref to first elem
    println!(&quot;v[0]: {}&quot;, first);
    return first.clone();
}</code></pre>
<pre class="rust-norun"><code>fn modify(v: &amp;mut Vec&lt;String&gt;, name: &amp;str) {
    let freshly_created = format!(&quot;Hello {}&quot;, name);
    v.push(freshly_created);
}</code></pre>
<pre class="rust-norun"><code>fn consume(v: Vec&lt;String&gt;) -&gt; String {
    for s in v { return s; }
    panic!(&quot;v was empty?!?&quot;);
}</code></pre>
<pre class="rust-norun"><code>fn read(v: &amp;Vec&lt;String&gt;) -&gt; String { ... }
fn modify(v: &amp;mut Vec&lt;String&gt;, name: &amp;str) { ... }
fn consume(v: Vec&lt;String&gt;) -&gt; String { ... }</code></pre>
</section></section>
<section><section id="oop" class="titleslide slide level1"><h1>OOP ?</h1></section><section id="structs-und-enums" class="slide level2">
<h1>Structs und Enums</h1>
</section><section id="impl" class="slide level2">
<h1>Impl</h1>
</section><section id="traits" class="slide level2">
<h1>Traits</h1>
</section><section class="slide level2">

</section></section>
<section><section id="here-be-dragons" class="titleslide slide level1"><h1>here be dragons</h1></section><section id="der-rest-ist-unsortiert" class="slide level2">
<h1>der rest ist unsortiert</h1>
<ul>
<li>Traits vs Object Orientation -&gt; composition vs inheritance</li>
<li>Trait based Generics vs Templates -&gt; no ducktyping in &quot;template&quot; expansions</li>
<li>no nullpointers =&gt; functions return <code>Option&lt;T&gt;</code> or <code>Result&lt;T&gt;</code></li>
<li>functional style Error Handling, no exceptions :)</li>
</ul>
</section><section id="concurrency" class="slide level2">
<h1>Concurrency</h1>
<ul>
<li>mpsc channels</li>
<li>ownership is enforced -&gt; no Dataraces</li>
<li>shared access through <code>Arc</code></li>
</ul>
<pre class="rust"><code>use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(
        Mutex::new(
            vec![1, 2, 3]
            )
        );

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}</code></pre>
</section><section id="macros" class="slide level2">
<h1>Macros</h1>
<ul>
<li>very unlike C/C++ Macros</li>
<li>work on AST after parser</li>
<li><strong>example</strong></li>
</ul>
</section></section>
<section><section id="handson-life-coding-examples" class="titleslide slide level1"><h1>HandsOn: Life Coding Examples</h1></section><section id="basics" class="slide level2">
<h1>Basics</h1>
<ol>
<li>(im)mutability</li>
<li>primitives and tuple, enum, struct</li>
<li>control flow (if, loop, while)</li>
<li>expressions vs statements</li>
<li>println!()</li>
</ol>
</section><section id="get-rusty" class="slide level2">
<h1>Get Rusty</h1>
<ol>
<li>references (e.g. String vs &amp;str)</li>
<li>Option and Result</li>
<li>pattern matching (match, if let)</li>
<li>error handling, simple</li>
</ol>
</section><section id="stdlib" class="slide level2">
<h1>Stdlib</h1>
<ol>
<li>collections</li>
<li>iterators</li>
</ol>
</section><section id="advanced" class="slide level2">
<h1>Advanced</h1>
<ol>
<li>closures</li>
<li>traits, trait bounds</li>
<li>documentation comments, in-line tests <code>#[test]</code> and benchmarks <code>#[bench]</code></li>
<li>error handling, closer look</li>
</ol>
</section><section id="for-completeness-sake" class="slide level2">
<h1>For Completeness Sake</h1>
<ol>
<li>modules</li>
<li>macros ( please don't )</li>
</ol>
</section></section>
<section><section id="extension-slides" class="titleslide slide level1"><h1>Extension Slides</h1></section><section id="section" class="slide level2">
<h1></h1>
</section></section>
<section><section id="alternatives-to-rust" class="titleslide slide level1"><h1>alternatives to Rust?</h1></section><section id="go" class="slide level2">
<h1>Go</h1>
<ul>
<li>(+) compiles faster than rust</li>
<li>(+) statically compiled and linked</li>
<li>(-) strange design decisions</li>
<li>(-) nothing groundbreaking</li>
<li>(-) garbage collected</li>
<li>(-) completely separate toolchain</li>
<li>-&gt; more competition to java</li>
</ul>
</section><section id="c17-gsl" class="slide level2">
<h1>C++17 + GSL</h1>
<ul>
<li>(+) fits in existing codebase</li>
<li>(-) reiteration of codebase necessary</li>
<li>(-) large language, old style still possible</li>
<li>(-) language makes static compile time checks nontrivial</li>
</ul>
</section><section id="haskell" class="slide level2">
<h1>Haskell</h1>
<ul>
<li>(+) safe</li>
<li>(-) not intended for systems programming</li>
</ul>
</section><section id="swift" class="slide level2">
<h1>Swift</h1>
<ul>
<li>no garbage collection, by reference counting</li>
<li><code>Optional</code> is similar to <code>Option&lt;T&gt;</code>, but equivalent to <code>Result&lt;T&gt;</code> is 3rd party</li>
</ul>
</section><section id="disadvantages-of-rust" class="slide level2">
<h1>disadvantages of Rust</h1>
<ul>
<li>price of safety: may slightly reduce performance</li>
<li>bigger bins</li>
<li>ABI compatible with C but not with C++, requires wrappers or <code>extern c</code></li>
<li>static linking by default</li>
<li>builds against glibc, musl (experimental), uclibc (not tested)</li>
</ul>
<!--
# Community and Documentation

## Community and Documentation

* users.rust-lang.org
* http://rustbyexample.com/
* http://doc.rust-lang.org/stable/book/
* http://www.reddit.com/r/rust
* http://rustyrad.io/
* http://this-week-in-rust.org/
* http://cglab.ca/~abeinges/blah/turpl/_book/

# eco system
* cargo as package manager and build system
* crates.io as repo, extern git repositories, explizite

-->


</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>
  <script src="jquery-1.12.0.min.js"></script>
  <script src="add_playpen.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
